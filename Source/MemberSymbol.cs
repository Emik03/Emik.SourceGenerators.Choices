// SPDX-License-Identifier: MPL-2.0
namespace Emik.SourceGenerators.Choices;

/// <summary>Represents a named member, typically a field or property.</summary>
/// <param name="Type">The type of the member.</param>
/// <param name="Name">The name of the member.</param>
/// <param name="Symbol">The underlying symbol, if any.</param>
public readonly record struct MemberSymbol(ITypeSymbol Type, string Name, ISymbol? Symbol = null)
{
    [StringSyntax("C#")]
    const string Action = "global::System.Action", Func = "global::System.Func";

    static readonly ImmutableArray<string> s_emptyTypeNames = AsImmutableArray(
        [
            typeof(void).Name,
            nameof(ValueTuple),
            nameof(YieldAwaitable),
            nameof(YieldAwaitable.YieldAwaiter),
            "TotalOrderIeee754Comparer",
            "GenericPlaceholder",
            "TestAccessor",
            "Nothing",
            "Unit",
        ]
    );

    /// <summary>Initializes a new instance of the <see cref="MemberSymbol"/> struct.</summary>
    /// <param name="field">The field.</param>
    public MemberSymbol(IFieldSymbol field)
        : this(field.Type, field.GetFullyQualifiedName(), field) { }

    /// <summary>Initializes a new instance of the <see cref="MemberSymbol"/> struct.</summary>
    /// <param name="parameter">The parameter.</param>
    public MemberSymbol(IParameterSymbol parameter)
        : this(parameter.Type, parameter.GetFullyQualifiedName(), parameter) { }

    /// <summary>Initializes a new instance of the <see cref="MemberSymbol"/> struct.</summary>
    /// <param name="property">The property.</param>
    public MemberSymbol(IPropertySymbol property)
        : this(property.Type, property.GetFullyQualifiedName(), property) { }

    /// <summary>
    /// Gets the <see cref="IEqualityComparer{T}"/> for <see cref="MemberSymbol"/> for referential equality.
    /// </summary>
    [Pure]
    public static IEqualityComparer<MemberSymbol> Referential { get; } = Equating<MemberSymbol>(
        (x, y) => x.ReferenceEquals(y),
        x => StringComparer.Ordinal.GetHashCode(x.Name) ^ EqualityComparer<ITypeSymbol>.Default.GetHashCode(x.Type)
    );

    /// <summary>Determines whether <see cref="Type"/> is a unit type.</summary>
    [Pure]
    public bool IsEmpty =>
        Type is { BaseType.SpecialType: not SpecialType.System_Enum, IsValueType: true } type &&
        !type.IsUnmanagedPrimitive() &&
        s_emptyTypeNames.Contains(type.Name, StringComparer.Ordinal) &&
        type.GetMembers().All(IsSymbolEmpty);

    /// <summary>Gets a value indicating whether the member is an equality contract generated by record types.</summary>
    [Pure]
    public bool IsEq =>
        Symbol is IPropertySymbol
        {
            ContainingType.IsRecord: true,
            Name: "EqualityContract",
            Type:
            {
                ContainingNamespace: { ContainingNamespace.IsGlobalNamespace: true, Name: nameof(System) },
                Name: nameof(Type),
            },
        };

    /// <summary>Gets a value indicating whether the member has <see cref="IComparable{T}.CompareTo"/>.</summary>
    [Pure]
    public bool IsInterfaceComparable => Type.GetMembers().Any(x => IsSingleSelf(x, nameof(IComparable.CompareTo)));

    /// <summary>Gets a value indicating whether the member has <see cref="IEquatable{T}.Equals"/>.</summary>
    [Pure]
    public bool IsInterfaceEquatable => Type.GetMembers().Any(x => IsSingleSelf(x, nameof(Equals)));

    /// <summary>Gets a value indicating whether the member has an operator comparison method.</summary>
    [Pure]
    public bool IsOperatorComparable =>
        Type is IPointerTypeSymbol ||
        Type.BaseType?.SpecialType is SpecialType.System_Enum ||
        Type.IsUnmanagedPrimitive() ||
        Type.GetMembers().Any(x => IsOperator(x, "op_GreaterThan"));

    /// <summary>Gets a value indicating whether the member has an operator equality method.</summary>
    [Pure]
    public bool IsOperatorEquatable =>
        Type is IPointerTypeSymbol ||
        Type.BaseType?.SpecialType is SpecialType.System_Enum ||
        Type.IsUnmanagedPrimitive() ||
        Type.GetMembers().Any(x => IsOperator(x, "op_Equality"));

    /// <summary>Gets a value indicating whether the type is a reference type.</summary>
    [Pure]
    public bool IsReference =>
        Type is { IsReferenceType: true } or
            ITypeParameterSymbol { ConstraintTypes: not [] } or
            ITypeParameterSymbol { HasReferenceTypeConstraint: true };

    /// <summary>Gets a value indicating whether the member is static.</summary>
    [Pure]
    public bool IsStatic => Symbol is { IsStatic: true };

    /// <summary>Gets a value indicating whether the type is unmanaged.</summary>
    [Pure]
    public bool IsUnmanaged => Type.IsUnmanagedType && Type is not ITypeParameterSymbol;

    /// <summary>
    /// Gets a string representation with the <see cref="NullableAnnotation.NotAnnotated"/> annotation.
    /// </summary>
    [Pure]
    public string NotNullableAnnotated => $"{Type.WithNullableAnnotation(NullableAnnotation.NotAnnotated)}";

    /// <summary>Gets a string representation with the <see cref="NullableAnnotation.Annotated"/> annotation.</summary>
    [Pure]
    public string NullableAnnotated => $"{Type.WithNullableAnnotation(NullableAnnotation.Annotated)}";

    /// <summary>Gets a string suffix for nullable suppression.</summary>
    [Pure]
    public string NullableSuppression => Type.IsValueType ? "" : "!";

    /// <summary>Gets the field declaration with an explicit offset for the internal unmanaged struct.</summary>
    [Pure]
    public string UnmanagedFieldDeclaration =>
        $"""
                 [global::{typeof(FieldOffsetAttribute)}(0)]
                 internal {Unsafe}{Type} {FieldName};
         """;

    /// <summary>Gets the name of the field that corresponds to this <see cref="MemberSymbol"/>.</summary>
    [Pure]
    public string FieldName => $"_{ParameterName}";

    /// <summary>Gets the name of the parameter that corresponds to this <see cref="MemberSymbol"/>.</summary>
    [Pure]
    public string ParameterName => $"{FirstCharName?.ToLower()}{RestName}";

    /// <summary>Gets the name of the property that corresponds to this <see cref="MemberSymbol"/>.</summary>
    [Pure]
    public string PropertyName => $"{FirstCharName?.ToUpper()}{RestName}";

    /// <summary>Gets the XML name that corresponds to this <see cref="MemberSymbol"/>.</summary>
    [Pure]
    public string XmlName => IsEmpty ? $"<c>{PropertyName}</c>" : $"<see cref=\"{PropertyName}\"/>";

    /// <summary>Gets the unsafe modifier of the type that corresponds to this <see cref="MemberSymbol"/>.</summary>
    [Pure]
    public string Unsafe => Type.IsUnsafe() ? "unsafe " : "";

    /// <summary>
    /// Gets the first character of the name of the parameter that corresponds to this <see cref="MemberSymbol"/>.
    /// </summary>
    [Pure]
    char? FirstCharName => Name.Nth((Name is ['_', ..]).ToByte());

    /// <summary>
    /// Gets the rest of the name of the parameter that corresponds to this <see cref="MemberSymbol"/>.
    /// </summary>
    [Pure]
    ReadOnlySpan<char> RestName => Name.AsSpan().Nth(((Name is ['_', ..]).ToByte() + 1)..);

    /// <summary>Compares two <see cref="INamespaceOrTypeSymbol"/> instances.</summary>
    /// <remarks><para>
    /// As opposed to <see cref="RoslynComparer.Instance"/>, this method also checks for the members
    /// of <see cref="INamespaceOrTypeSymbol"/> instances if they are declared in source, since both instances
    /// could have the same metadata name but come from different iterations of source code.
    /// </para></remarks>
    /// <param name="x">The first <see cref="INamespaceOrTypeSymbol"/> to compare.</param>
    /// <param name="y">The second <see cref="INamespaceOrTypeSymbol"/> to compare.</param>
    /// <returns>Whether the two <see cref="INamespaceOrTypeSymbol"/> instances are equal.</returns>
    [Pure]
    public static bool Equal(INamespaceOrTypeSymbol? x, INamespaceOrTypeSymbol? y) =>
        ReferenceEquals(x, y) ||
        x is not null && y is not null && (SourcedEquals(x, y) || UnsourcedEquals(x, y));

    /// <summary>Determines if the <see cref="ISymbol"/> is an operator.</summary>
    /// <param name="symbol">The <see cref="ISymbol"/> to check.</param>
    /// <param name="expect">The expected name of the operator.</param>
    /// <returns>
    /// The value <see langword="true"/> if the <see cref="ISymbol"/>
    /// is an operator; otherwise, <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsOperator(ISymbol symbol, string expect) =>
        symbol is IMethodSymbol
        {
            IsStatic: true,
            Name: var name,
            DeclaredAccessibility: Accessibility.Public,
            MethodKind: MethodKind.BuiltinOperator,
        } &&
        expect == name;

    /// <summary>Determines if the <see cref="ISymbol"/> is a method that has one parameter of itself.</summary>
    /// <param name="x">The <see cref="ISymbol"/> to check.</param>
    /// <param name="expect">The expected name of the parameter.</param>
    /// <returns>
    /// The value <see langword="true"/> if the <see cref="ISymbol"/> is a method
    /// that has one parameter of itself; otherwise, <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsSingleSelf(ISymbol x, string expect) =>
        x is IMethodSymbol
        {
            Name: var name,
            IsStatic: false,
            ContainingType: { } type,
            Parameters: [{ Type: INamedTypeSymbol other }],
        } &&
        expect == name &&
        RoslynComparer.Signature.Equals(type, other);

    /// <summary>Determines if the <see cref="ISymbol"/> could fit within a unit type.</summary>
    /// <param name="x">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the <see cref="ISymbol"/> could
    /// fit within a unit type; otherwise, <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsSymbolEmpty(ISymbol x) =>
        x is { IsStatic: true } or
            not IFieldSymbol and not IMethodSymbol { MethodKind: MethodKind.Constructor, Parameters: not [] };

    /// <summary>Determines if the <see cref="ITypeSymbol"/> is a <see cref="System.Tuple"/>.</summary>
    /// <param name="symbol">The <see cref="ITypeSymbol"/> to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the <see cref="ITypeSymbol"/>
    /// is a <see cref="System.Tuple"/>; otherwise, <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsSystemTuple([NotNullWhen(true)] ITypeSymbol? symbol) =>
        symbol is INamedTypeSymbol
        {
            Name: nameof(Tuple),
            TypeArguments.Length: > 1,
            ContainingNamespace: { Name: nameof(System), ContainingNamespace.IsGlobalNamespace: true },
        };

    /// <summary>Gets the name of the delegate type.</summary>
    /// <param name="hasGenericReturn">
    /// The value <see langword="true"/> if the delegate has a generic return type; otherwise, <see langword="false"/>.
    /// </param>
    /// <returns>The name of the delegate type.</returns>
    [Pure]
    public string DelegateTypeName(bool hasGenericReturn) =>
        $"{(this is { IsEmpty: false, Type: IPointerTypeSymbol or { IsRefLikeType: true } }
            ? $"{PropertyName}Handler"
            : hasGenericReturn ? Func : Action)}{(
            this is { IsEmpty: true } or { Type: IPointerTypeSymbol or { IsRefLikeType: true } }
                ? hasGenericReturn ? $"<{Scaffolder.ResultGeneric}>" : ""
                : hasGenericReturn ? $"<{Type}, {Scaffolder.ResultGeneric}>" : $"<{Type}>")}";

    /// <summary>Creates a new instance of the <see cref="MemberSymbol"/> struct from the underlying symbol.</summary>
    /// <param name="symbol">The <see cref="ISymbol"/> to create the <see cref="MemberSymbol"/> from.</param>
    /// <returns>The new <see cref="MemberSymbol"/> instance.</returns>
    [Pure]
    public static MemberSymbol? From(ISymbol symbol) =>
        symbol switch
        {
            IFieldSymbol { CanBeReferencedByName: true } x => new(x),
            IPropertySymbol { CanBeReferencedByName: true } x => new(x),
            IParameterSymbol { CanBeReferencedByName: true } x => new(x),
            _ => null,
        };

    /// <summary>Determines whether the name has the possibility of conflict.</summary>
    /// <param name="name">The name to check.</param>
    /// <returns>
    /// The value <paramref name="true"/> if the parameter <paramref name="name"/>
    /// contains a name that may conflict with this instance.
    /// </returns>
    public bool CanConflict(string name) =>
        Name.AsSpan() is ['_', .. { IsEmpty: false } rest] &&
        (name.AsSpan().SequenceEqual(rest) ||
            rest[..1].EqualsIgnoreCase(name.AsSpan(0, 1)) && rest[1..].SequenceEqual(name.AsSpan(1))) ||
        Name.AsSpan(0, 1).EqualsIgnoreCase(name.AsSpan(0, 1)) && Name.AsSpan(1).SequenceEqual(name.AsSpan(1));

    /// <inheritdoc />
    [Pure]
    public bool Equals(MemberSymbol other) =>
        Symbol?.Kind == other.Symbol?.Kind && Name == other.Name && Equal(Type, other.Type);

    /// <summary>Compares two <see cref="MemberSymbol"/> instances by its references.</summary>
    /// <param name="other">The other <see cref="MemberSymbol"/> to compare.</param>
    /// <returns>
    /// The value <see langword="true"/> if the two <see cref="MemberSymbol"/>
    /// instances hold the same references; otherwise, <see langword="false"/>.
    /// </returns>s
    [Pure]
    public bool ReferenceEquals(MemberSymbol other) => (object)Name == other.Name && ReferenceEquals(Type, other.Type);

    /// <summary>Compares two <see cref="MemberSymbol"/> instances by <see cref="Type"/>.</summary>
    /// <param name="other">The other <see cref="MemberSymbol"/> to compare.</param>
    /// <returns>
    /// The value <see langword="true"/> if the two <see cref="MemberSymbol"/> instances
    /// have the same <see cref="Type"/>; otherwise, <see langword="false"/>.
    /// </returns>s
    [Pure]
    public bool TypeEquals(MemberSymbol other) => RoslynComparer.Signature.Equals(Type, other.Type);

    /// <inheritdoc />
    [Pure]
    public override int GetHashCode() =>
        Symbol switch
        {
            IFieldSymbol field => RoslynComparer.Signature.GetHashCode(field) * Prime(),
            IPropertySymbol property => RoslynComparer.Signature.GetHashCode(property) * Prime(),
            IParameterSymbol parameter => RoslynComparer.Signature.GetHashCode(parameter) * Prime(),
            _ => RoslynComparer.Signature.GetHashCode(Type) ^ StringComparer.Ordinal.GetHashCode(Name) * Prime(),
        };

    /// <inheritdoc />
    [Pure]
    public override string ToString() =>
        Symbol switch
        {
            IFieldSymbol => $"{Type} {Name};",
            IParameterSymbol => $"{Type} {Name}",
            IPropertySymbol => $"{Type} {Name} {{ get; }}",
            _ => $"{Name}<{Type}>",
        };

    /// <summary>Determines if both symbols are equal and in source.</summary>
    /// <param name="x">The first <see cref="INamespaceOrTypeSymbol"/> to compare.</param>
    /// <param name="y">The second <see cref="INamespaceOrTypeSymbol"/> to compare.</param>
    /// <returns>Whether the two <see cref="INamespaceOrTypeSymbol"/> instances are equal.</returns>
    static bool SourcedEquals(INamespaceOrTypeSymbol x, INamespaceOrTypeSymbol y) =>
        y.IsInSource() &&
        RoslynComparer.Signature.Equals(x, y) &&
        x.GetMembers().GuardedSequenceEqual(y.GetMembers(), RoslynComparer.Signature) &&
        x.GetTypeMembers().GuardedSequenceEqual(y.GetTypeMembers(), RoslynComparer.Signature);

    /// <summary>Determines if both symbols are equal but both not in source.</summary>
    /// <param name="x">The first <see cref="INamespaceOrTypeSymbol"/> to compare.</param>
    /// <param name="y">The second <see cref="INamespaceOrTypeSymbol"/> to compare.</param>
    /// <returns>Whether the two <see cref="INamespaceOrTypeSymbol"/> instances are equal.</returns>
    static bool UnsourcedEquals(ISymbol x, ISymbol y) => !y.IsInSource() && RoslynComparer.Signature.Equals(x, y);
}
